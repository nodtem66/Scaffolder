{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scaffolder","text":"<p>The triply periodic minimal surface (TPMS) topology is beautiful. They constructed from a mathematical implicit function \\(f(x,y,z)=0\\) and resulted in 3D mesh by Marching cubes. However, the creating process of a TPMS mesh from a complex shape like human bone is quite complicated. \"Scaffolder\" offers the easy solution via commandline, Python API, and Blender plugins.</p>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Volumetric CAD</li> <li>Surface visualization</li> <li>Multi-morphology porous scaffold design</li> <li>Porous bone implant design</li> <li>Finite element analysis (FEA)</li> </ul>"},{"location":"#how-it-works","title":"How it works","text":"<ul> <li>Read STL file and finding the boundary box</li> <li>Generate the grid and calculate the winding number with STL mesh</li> <li>Generate the 3D isosurface field</li> <li>Perform Dual marching cube to construct the 3D mesh</li> <li>Clean up the duplicated vertices or faces, and abandon the group of connected faces having the diameter below the setting</li> <li>Export to the target 3D format</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Computational method and program for generating a porous scaffold based on implicit surfaces <pre><code>@article{IAMSAMANG2021106088,\ntitle = {Computational method and program for generating a porous scaffold based on implicit surfaces},\njournal = {Computer Methods and Programs in Biomedicine},\nvolume = {205},\npages = {106088},\nyear = {2021},\nissn = {0169-2607},\ndoi = {https://doi.org/10.1016/j.cmpb.2021.106088},\nurl = {https://www.sciencedirect.com/science/article/pii/S0169260721001632},\nauthor = {Jirawat Iamsamang and Phornphop Naiyanetr},\nkeywords = {Triply periodic minimal surface (TPMS), Implicit surface, Porous scaffold, Pore size, Porosity}\n}\n</code></pre></p>"},{"location":"blender/","title":"Blender plugin","text":"<p>After the PyScaffolder addon for Blender is installed and enabled, press N or View &gt; Sidebar to show a sidebar tab in right-hand side. Then Scaffolder will be found in one tab of a that sidebar, as shown in the following figure.</p> <p></p> <p>See Command line for the description of the parameters used in mesh generation.</p>"},{"location":"blender/#video","title":"Video","text":""},{"location":"cmd/","title":"Command line","text":"<pre><code>Scaffolder - generate 3D scaffold from STL file\nUsage:\n  Scaffolder [OPTION...] INPUT OUTPUT PARAMETERS\n\n  -h, --help                    Print help\n  -i, --input INPUT             Input file (STL/PLY/OFF/OBJ/VMI)\n  -o, --output OUTPUT           Output filename with extension\n                                stl,ply,obj,off,ctm\n      --params PARAMETERS       Combined parameters list:\n                                surface[,coff,isolevel,grid_size,k_slice,k_polygon]\n  -q, --quiet                   Disable verbose output [default: false]\n  -c, --coff DOUBLE             Angular frequency (pore size adjustment)\n                                default:PI\n  -t, --isolevel DOUBLE         isolevel (porosity adjustment) [default: 0]\n  -n, --surface NAME            implicit surface: rectlinear, schwarzp,\n                                schwarzd, gyroid, double-p, double-d,\n                                double-gyroiod, lidinoid, schoen_iwp, neovius, bcc,\n                                tubular_g_ab, tubular_g_c (default: bcc)\n  -g, --grid_size INT (0..60000)\n                                Grid size [default: 100]\n  -s, --shell INT (0..60000)    Outer thickness (layers) [default:0]\n      --grid_offset INT (0..60000)\n                                [default:3]\n  -m, --microstructure          Analysis microstructure with Slice contour\n                                technique ( [default: false]\n      --export_microstructure   Analysis microstructure and export the 2D\n                                contours (for debugging) [default: false]\n      --export_jpeg [X|Y|Z],INT\n                                Export 2D JPEG (Default: Z,100)\n      --k_slice INT (0..60000)  K_slice: the number of slicing layers in each\n                                direction (used in microstructure analysis)\n                                (default: 100)\n      --k_polygon INT (&gt;0)      K_polygon: the number of closest outer\n                                contour (used in microstructure analysis) (default:\n                                4)\n  -z, --size_optimize DOUBLE (0..1)\n                                Experimental Quadric simplification (default:\n                                0)\n      --smooth_step INT (0..60000)\n                                Smooth with laplacian (default: 0)\n      --dirty                   Disable autoclean\n      --minimum_diameter DOUBLE (0..1)\n                                used for removing small orphaned (between\n                                0-1) (default: 0.25)\n      --format FORMAT (default, csv)\n                                Format of logging output (default: default)\n      --output_inverse          additional output inverse scaffold\n      --fix_self_intersect INT  Experimental fix self-intersect faces\n                                (default: 0)\n      --mean_curvature INT      Size of mean curvature histogram (default: 0)\n      --no_intersect            Generate 3D mesh without intersect with\n                                original mesh (false)\n</code></pre>"},{"location":"cmd/#examples","title":"Examples","text":"<ul> <li> <p>Generated BCC scaffold with \\(w=\\pi\\), \\(t=0\\), and \\(grid\\_size=100\\) <pre><code>  Scaffolder input.stl output.stl bcc,3.14159,0,100\n</code></pre></p> </li> <li> <p>Generated custom implicit function (declaired in <code>custom.lua</code>) with \\(w=\\pi\\), \\(t=0\\), \\(grid\\_size=100\\), \\(k_{slice}=100\\), \\(k_{polygon}=4\\) and evaluated scaffold properties <pre><code>  Scaffolder input.stl output.stl custom.lua,3.14159,0,100,100,4 -m\n</code></pre></p> </li> <li> <p>Generated and evaluated BCC scaffold (\\(w=3.14159\\), \\(t=0\\)) and reported in CSV <pre><code>Scaffolder input.stl output.stl bcc,3.14159,0 -m -q --format csv\n</code></pre></p> </li> </ul>"},{"location":"cmd/#custom-implicit-function","title":"Custom implicit function","text":"<p>If the built-in functions (<code>rectlinear, schwarzp, schwarzd, gyroid, double-p, double-d, double-gyroiod, lidinoid, schoen_iwp, neovius, bcc, tubular_g_ab, tubular_g_c</code>) was not satisfied, the custom implicit function can be used by creating a lua file and define the \"surface\" function that return the FRep</p> <pre><code>-- custom.lua \n-- define gyroid with\nfunction surface (x, y, z)\n    return -(sin(x) * cos(y) + sin(y) * cos(z) + sin(z) * cos(x) - params.isolevel)\nend\n</code></pre> <p>The special symbols can be used in lua file: <pre><code>  params = { coff, isolevel, k_splice, k_polygon }\n  bbox = { min, max, length, grid_density }\n  winding(x,y,z) -- function returning the winding number of position x,y,z\n  signed_distance(x,y,z) -- function returning signed distance of position x,y,z\n</code></pre> and also all functions in math module</p>"},{"location":"installation/","title":"Installation","text":"<p>Scaffolder supports the command-line usage by standalone program, python scripting via PyPI, and blender by python-wrapped plugin.</p>"},{"location":"installation/#standalone-program","title":"Standalone program","text":"<p>The binary programs for various platforms are automatically built and deposited on the public repository: Github and Anaconda. </p>"},{"location":"installation/#github","title":"Github","text":"<ol> <li>Download <code>bin64.zip</code> from Github Releases page</li> <li>Extract <code>bin64.zip</code> which contains the following files:  <pre><code>\u251c\u2500\u2500\u2500macos\n\u2502       PyScaffolder.cpython-39-darwin.so\n\u2502       Scaffolder\n\u2502       Scaffolder.SliceTest\n\u2502\n\u251c\u2500\u2500\u2500ubuntu\n\u2502       PyScaffolder.cpython-36m-x86_64-linux-gnu.so\n\u2502       Scaffolder\n\u2502       Scaffolder.SliceTest\n\u2502\n\u2514\u2500\u2500\u2500windows\n    \u2514\u2500\u2500\u2500Release\n            PyScaffolder.cp37-win_amd64.pyd\n            PyScaffolder.exp\n            PyScaffolder.lib\n            Scaffolder.exe\n            Scaffolder.SliceTest.exe\n</code></pre></li> <li>Open command line at the directory according to your platform, such as <code>windows/Release</code> for window.</li> <li>Test the program with <code>--help</code> <pre><code>Scaffolder --help\nScaffolder.SliceTest --help\n</code></pre></li> </ol> <p>Note</p> <p><code>PyScaffolder.cpython-&lt;python_version&gt;-&lt;platform&gt;</code> is a compiled python bytecode that can import to a python script as a module (see Python supports). </p>"},{"location":"installation/#anaconda","title":"Anaconda","text":"<ol> <li>Install Anaconda or miniconda</li> <li>Conda can manage the environments and revisions, then:<ul> <li>If you want to install <code>Scaffolder</code> into current environment, use:   <pre><code>conda install -c nodtem66 scaffolder\n</code></pre></li> <li>If you want to install <code>Scaffolder</code> into a new environment due to the conflicted from some dependencies, use:   <pre><code>conda install -n new_env -c nodtem66 scaffolder\nconda activate new_env\n</code></pre></li> </ul> </li> <li>Test the program with <code>--help</code> <pre><code>Scaffolder --help\nScaffolder.SliceTest --help\n</code></pre></li> </ol>"},{"location":"installation/#python-supports","title":"Python supports","text":"<p>The current version of <code>Scaffolder</code> supports python <code>3.6</code>, <code>3.7</code>, <code>3.8</code>, and <code>3.9</code> with only <code>x86_64</code> platform on:</p> <ul> <li>Window 10 (didn't test with the older version)</li> <li>Linux</li> <li>OSX 10</li> </ul> <p>Note</p> <p>see the list of available version at PyPI</p> <p>Then install via <code>pip</code> <pre><code>pip install PyScaffolder\n</code></pre></p> <p>The following script is an example usage of <code>PyScaffolder</code>. <pre><code>import PyScaffolder\n\n# Load vertices and faces of a 20mm cube\nv = [\n    [0.0, 0.0, 0.0],\n    [20.0, 0.0, 0.0],\n    [0.0, -20.0, 0.0],\n    [20.0, -20.0, 0.0],\n    [0.0, 0.0, 20.0],\n    [20.0, 0.0, 20.0],\n    [0.0, -20.0, 20.0],\n    [20.0, -20.0, 20.0]\n]\n\nf = [\n    [1, 2, 0],\n    [2, 1, 3],\n    [7, 2, 3],\n    [2, 7, 6],\n    [1, 7, 3],\n    [7, 1, 5],\n    [7, 4, 6],\n    [4, 7, 5],\n    [4, 2, 6],\n    [2, 4, 0],\n    [4, 1, 0],\n    [1, 4, 5]\n]\nprint(\"Vertices: \", len(v))\nprint(\"Faces: \", len(f))\n\n# Test Slice test with all direction\na = PyScaffolder.slice_test(v, f, direction=3)\nprint(len(a.minFeret))\n\n# Set default parameter\nparams = PyScaffolder.Parameter()\nparams.coff = 1.0\n\n# Test the mesh generation from v,f\na = PyScaffolder.generate_scaffold(v, f, params)\nprint(a.porosity)\nprint(a.surface_area_ratio)\nprint(len(a.v), len(a.f))\n</code></pre></p> <p>See Python API for details.</p>"},{"location":"installation/#blender-addon","title":"Blender addon","text":"<ol> <li>Download <code>Scaffolder-blender.zip</code> from Github, which contains following files (see also /blender): <pre><code>\u2514\u2500\u2500\u2500Scaffolder\n    SCAFFOLDER_OP_generate_mesh.py\n    SCAFFOLDER_OP_slice_test.py\n    SCAFFOLDER_PT_generate_mesh.py\n    SCAFFOLDER_PT_slice_test.py\n    SCAFFOLDER_settings.py\n    utils.py\n    __init__.py\n</code></pre></li> <li>Open Blender &gt; Edit &gt; Preferences &gt; Add-ons &gt; Install, select <code>Scaffolder-blender.zip</code>, and check the box to enable it.</li> <li>Press N or View &gt; Sidebar. Then Scaffolder will be found in one tab of a sidebar.</li> </ol> <p>See Blender plugin for video and more information.</p>"},{"location":"other_tools/","title":"Other tools","text":"<p>MSLattice, FLatt Pack, and Scaffolder were used to generate the 2 units of Gyroid (20mm\u00d720mm\u00d720mm).</p> <p>The porosity was set to 70% (30% volume fraction).</p> <p>MSLattice and FLatt Pack defined mesh density or discretization per unit cell, whereas Scaffolder defined grid size for entire structure.</p> <p>Hence, the mesh density points and discretization were set to 100, while Scaffolder\u2019s grid size was set to 200, </p> <p>the following relation between the number of unit cells (N), mesh length (L), unit cell size (l), and angular frequency (\u03c9) is: $$$ w=2\\piNL=2\\pil $$$</p> <p>Parameters used to generate Gyroid meshes Program Parameter MSLattice Uniform TPMS Lattices with solid network. Architecture = Gyroid, Relative density = 30, Unit cell size = 10 Sample Length = 20, Sample Width = 20, Sample Height = 20 Mesh Density Points = 100 FLatt Pack Geometry = Cuboid, Dimensions (x,y,z) = (20,20,20), Cells (x,y,z) = (2,2,2), Phase=Network (Gyroid), Discretisation = 100, Volume fraction =  Uniform (0.3), No skin Scaffolder \u03c9=\u03c0/5, t=0.61, grid_size = 200 (Scaffolder cube20mm.stl out.stl gyroid,0.6283,0.61,200 --fix_self_intersect --intersect=false)</p>"},{"location":"python/","title":"Python API","text":"<p><code>PyScaffolder</code> is a wrapper for <code>Scaffolder</code>, which is written in C++.  It used PyBind11 to interface the C++ core function. The main core functions are <code>generate_scaffold</code> and <code>slice_test</code> which resemble the standalone program: <code>Scaffolder</code> and <code>Scaffolder.Slice</code>.</p>"},{"location":"python/#generate_scaffold","title":"generate_scaffold","text":"<pre><code>def generate_scaffold(vertices, faces, params=Parameter(), callback=None)\n</code></pre> Generate 3D mesh from input vertices, faces, and parameters"},{"location":"python/#parameters","title":"Parameters","text":"<ul> <li><code>vertices</code>: 2D array or numpy.array representing vertices in list of [x,y,z]   </li> <li><code>faces</code>: 2D array or numpy.array representing faces in list of [v1, v2, v3, v4]</li> <li><code>params</code>: Optional Parameter see the detail in Command line</li> <li><code>callback</code>: Optional function with one <code>integer</code> parameter indicating the progression</li> </ul>"},{"location":"python/#return","title":"Return","text":"MeshInfo"},{"location":"python/#example","title":"Example","text":"<pre><code>from PyScaffolder import generate_scaffold, Parameter\n\n# vertices and faces of a 20mm cube\nv = [\n    [0.0, 0.0, 0.0],\n    [20.0, 0.0, 0.0],\n    [0.0, -20.0, 0.0],\n    [20.0, -20.0, 0.0],\n    [0.0, 0.0, 20.0],\n    [20.0, 0.0, 20.0],\n    [0.0, -20.0, 20.0],\n    [20.0, -20.0, 20.0]\n]\n\nf = [\n    [1, 2, 0],\n    [2, 1, 3],\n    [7, 2, 3],\n    [2, 7, 6],\n    [1, 7, 3],\n    [7, 1, 5],\n    [7, 4, 6],\n    [4, 7, 5],\n    [4, 2, 6],\n    [2, 4, 0],\n    [4, 1, 0],\n    [1, 4, 5]\n]\n\n# the function required two parameters\nmesh_info = generate_scaffold(v, f)\n\n# use custom parameters\nparameter = Parameter()\nparameter.coff = 1.0\n\nmesh_info = generate_scaffold(v, f, parameter)\n\n# use callback to show % progression\ndef progression(n):\n  print(n)\n\nmesh_info = generate_scaffold(v, f, callback=progression)\n</code></pre>"},{"location":"python/#slice_test","title":"slice_test","text":"<pre><code>def slice_test(vertices, faces, k_slice=100, k_polygon=4, direction=0, callback=None)\n</code></pre> <p>Slice input mesh into pore sizes</p>"},{"location":"python/#parameters_1","title":"Parameters","text":"<ul> <li><code>vertices</code>: 2D array or numpy.array representing vertices in list of [x,y,z]   </li> <li><code>faces</code>: 2D array or numpy.array representing faces in list of [v1, v2, v3, v4]</li> <li><code>k_slice</code>: Optional integer \\(k_{slice}\\) the number of sliced layers</li> <li><code>k_polygon</code>: Optional integer \\(k_{polygon}\\) the number of nearest-neighbor polygon to measure Feret diameter</li> <li><code>direction</code> Optional integer representing slicing axis (0=X, 1=Y, 2=Z, 3=All)</li> <li><code>callback</code>: Optional function with one <code>integer</code> parameter indicating the progression</li> </ul>"},{"location":"python/#return_1","title":"Return","text":"PoreSize"},{"location":"python/#example_1","title":"Example","text":"<pre><code>import numpy as np\nimport trimesh\nimport PyScaffolder\n\n# load input.stl into mesh\nmesh = trimesh.load('input.stl')\n\n# slice all direction with default parameter\npore_size = PyScaffolder.slice_test(mesh.vertices, mesh.faces, direction=3)\nprint(len(pore_size.minFeret), len(pore_size.maxFeret))\n</code></pre>"},{"location":"python/#marching_cubes","title":"marching_cubes","text":"<pre><code>def marching_cubes(f, grid_size=(100,100,100), v_min=(0,0,0), delta=0.01, clean=False, callback=None)\n</code></pre> <p>Slice input mesh into pore sizes</p>"},{"location":"python/#parameters_2","title":"Parameters","text":"<ul> <li><code>f</code>: numpy.array representing a discrete isosurface where F(x,y,z) = 0 is boundary   </li> <li><code>grid_size</code>: Optional array, list, tuple, or int representing the number of voxels </li> <li><code>delta</code>: Optional array, list, tuple or double representing the dimension of a voxel</li> <li><code>v_min</code>: Optional array, list, tuple the coordinate of the corner of grid</li> <li><code>clean</code> Optional boolean that enable mesh cleaning after marching cubes</li> <li><code>callback</code>: Optional function with one <code>integer</code> parameter indicating the progression</li> </ul>"},{"location":"python/#return_2","title":"Return","text":"<code>(v, f)</code> representing vertices and faces in <code>np.array</code>"},{"location":"python/#example_2","title":"Example","text":"<pre><code>import PyScaffolder\nFxyz = [\n    1,1,1,1,\n    1,-1,-1,1,\n    1,-1,-1,1,\n    1,1,1,1\n]*4\n(v, f) = PyScaffolder.marching_cubes(\n    Fxyz,\n    grid_size=4,\n    delta=0.25,\n    v_min=(-.5, -.5, -.5),\n    callback = lambda x: print(x)\n)\n</code></pre>"},{"location":"python/#parameter","title":"Parameter","text":"<pre><code>class Parameter:\n    is_build_inverse = False\n    is_intersect = True\n    verbose = False\n    shell = 0\n    grid_offset = 5\n    smooth_step = 5\n    k_slice = 100\n    k_polygon = 4\n    fix_self_intersect = 0\n    grid_size = 100\n    isolevel = 0.0\n    qsim_percent = 0\n    coff = 3.141592653589793238462643383279502884\n    minimum_diameter = 0.25\n    surface_name = \"bcc\"\n</code></pre> Parameters implement from standalone program (see Command line)"},{"location":"python/#example_3","title":"Example","text":"<pre><code>from PyScaffolder import Parameter\nparams = Parameter()\nparams.coff = 1.0\n</code></pre>"},{"location":"python/#poresize","title":"PoreSize","text":"<pre><code>class PoreSize:\n    minFeret = np.array([])\n    maxFeret = np.array([])\n</code></pre> Collection of Minimum and Maximum Feret diameters, normally returned from slice_test"},{"location":"python/#meshinfo","title":"MeshInfo","text":"<pre><code>class MeshInfo:\n    v = np.array([[]])\n    f = np.array([[]])\n    porosity = 0.0\n    surface_area = 0.0\n    surface_area_ratio = 0.0\n</code></pre> Collection of triangular mesh resulted from generate_scaffold"},{"location":"tips/","title":"Tips","text":""},{"location":"tips/#what-is-the-value-of-w-used-for-pore-size-x","title":"What is the value of \\(w\\) used for pore size \\(x\\)?","text":"<p>The angular frequency (\\(w\\)) control the number of repetitive TPMS units:</p> \\[ w = 2\\pi / T = 2\\pi N / L \\] <p>where \\(T\\) = period or length of a unit cell, \\(N\\) = the number of unit cells, and \\(L\\) = the length of input 3D mesh.</p> <p>For example, if we want \\(N=2\\) in <code>cube20mm.stl</code> (\\(L=20mm\\)), \\(w\\) will be \\(2\\pi*2/20 = \\pi/5\\) (the unit of \\(L\\) has the same dimension with the input mesh).</p> <p></p> <p>The image show the Gyroid (left) and Double-Gyroid (right) with \\(w=\\pi/5\\) and \\(t=0\\). The pore size \\(x \\approx T/2\\) for Gyroid and \\(T/4\\) for Double-Gyroid. Then,</p> \\[ w \\approx \\left\\{ \\begin{array}{l} \\pi/x, &amp; \\text{for gyroid} \\\\  \\pi/2x, &amp; \\text{for double-gyroid} \\end{array} \\right. \\] <p>If we want a gyroid with \\(x=5mm\\), we will set \\(w=\\pi/5\\).</p>"},{"location":"tips/#example","title":"Example:","text":"<p><pre><code>./Scaffolder cube20mm.stl out.ply -c 3.14159 -g 100 -n tubulat_g_ab\n</code></pre> Program will generate the scaffold from <code>cube20mm.stl</code> (\\(L=20mm\\)) with theoretical \\(N=10\\)</p>"},{"location":"tips/#how-to-reduce-the-size-of-3d-mesh","title":"How to reduce the size of 3D mesh?","text":"<p>Scaffolder uses the Quadratic decimation from MeshLab to reduce the result 3D mesh with an option <code>--size_optimize</code> (<code>-z</code>). For example, the following command is used to generate a gyroid with 50% decimation, thus resulting the 50% less faces: <pre><code>./Scaffolder input.stl out.stl gyroid,0.6283,0.61,200 -z 0.5\n</code></pre></p> <p>Note</p> <p>You can manually reduce the size by using MeshLab: Filter &gt; Remeshing, Simplification, and Reconstruction &gt; Simplification: Quadric Edge Collapse Decimation</p>"},{"location":"tips/#how-to-intrepret-the-output-from-console","title":"How to intrepret the output from console?","text":"<p>Suppose that the following command was used:  <pre><code>.\\Scaffolder.exe .\\cube20mm.stl out.stl gyroid,0.6283,0.61,100\n</code></pre></p> <p>Then this is an output generated by program with default options (<code>--format default</code>)  <pre><code>[Scaffolder v1.5.1]\n-- Input file: .\\cube20mm.stl\n-- Output file: out.stl\n-- Surface (-n): gyroid\n-- Coff (-c): 0.6283\n-- Isolevel (-t): 0.61\n-- Grid size (-g): 100\n--   Grid offset: 3\n--   Shell: 0\n-- Autoclean: True\n--   Minimum diameter: 25%\n--   Smooth step: 5\n--   Fix self-intersect: False\n--   Quadric Simplification (-z): 0\n-- Analysis microstructure (-m): False\n--   Slice grid (k_slice): 100\n--   Nearest outer contours (k_polygon): 4\n--   Export microstructure: False\n--   Mean curvature: False\n-- Export JPEG: No\n--   Axis: X\n-- Build: Yes(Intersect)\n-- Bounding Box: [0, 0, 0] [20, 20, 20]\n-- Length: [20, 20, 20]\n-- Grid delta: 0.2\n[Generating grid] OK\n-- Grid size: 1191016 [106, 106, 106]\n[Calculating Winding number] OK\n-- Sign Distance: [ -1.03923, 9.99999]  Wind: [ -2.86488e-06, 1]\n[Generating isosurface Fxyz] OK\n[Marching Cube]\n[========================================] 100% 0.178s\n-- Info: 105896 vertices 211896 faces\n[libVCG Cleaning] OK\n[Laplacian smoothing] OK\n-- is_manifold: 1\n[Topology Measurement]\n-- Mesh is composed by 1 connected component(s)\n-- border edge: 0\n-- non-manifold edge: 0\n-- non-manifold vertex: 0\n-- self-intersect faces: 840\n-- Mesh is two-manifold\n-- Mesh has 0 holes\n-- Genus is 27\n[Scaffold properties]\n-- Volume: 2267.63\n-- Surface Area: 2855.25\n-- Porosity: 0.716547\n-- Surface Area ratio: 1.18969\n[Writing file] OK\n[Finished]\n</code></pre></p>"},{"location":"tips/#parameters-summary-lines-1-25","title":"Parameters summary (Lines 1-25)","text":"Line Parameter (value) Detail Refer to a process at 2 Input file (cube20mm.stl) Path to input file Line 26,Line 28 3 Output file (out.stl) Path to output file Line 51 4 Surface (gyroid) TPMS types Line 30 5 Coff (0.6283) Angular frequency (\\(w\\)) Line 30 6 Isolevel (0.61) Isolevel (\\(t\\)) Line 30 7 Grid size (100) Grid Resolution Line 26 8 Grid offset (3) Padding size adding to grid Line 26 9 Shell (0) Depth of solid shell Line 30 10 Autoclean (True) Clean 3D Mesh Line 34 11 Minimum diameter (25%) Minimal diameter (% of diagonal length of bounding box) to classify the small components in cleaning process Line 34 12 Smooth step (5) Steps to Laplacian smoothing Line 35 13 Fix self-intersect (False) Whether the program should fix the self-intersect or not Line 34 14 Quadric Simplification  (0) % triangles reduction NA 15 Analysis microstructure (False) Report the pore size NA 16 Slice grid (100) \\(k_{slice}\\) (the number of slice layers) NA 17 Nearest outer contours (4) \\(k_{polygon}\\) NA 18 Export microstructure (False) Export the SVG of sliced layers NA 19 Mean curvature (False) Calculate the mean curvature NA 20 Export JPEG (No) Export sliced layer NA 21 Axis (X) Axis to slice 3D Mesh NA 22 Build (True) Generate 3D Mesh Line 51 23 Bounding Box ([0, 0, 0] [20, 20, 20]) Two points of bounding box Line 26 24 Length ([20, 20, 20]) \\(\\text{Length}\\) of bonding box in [x, y, z] Line 26 25 Grid delta (0.2) \\(min(\\text{Length})/\\text{grid size}\\) Line 26"},{"location":"tips/#grid-generation-line-26","title":"Grid Generation (Line 26)","text":"<p>The voxels were generated based on \\(\\text{Length}/\\text{Grid delta} + 2(\\text{Grid offset})\\).  In this case, the grid size of (X, Y, Z) is \\((20, 20, 20)/0.2 + 2(3) = (106, 106, 106)\\)  and the total number of voxels is \\(106\\times106\\times106=1191016\\)</p>"},{"location":"tips/#winding-number-and-sdf-calculation-line-28","title":"Winding number and SDF calculation (Line 28)","text":"<p>The winding number and SDF with \\(106\\times106\\times106\\) voxels was calculated based on vertices and faces from input file.</p>"},{"location":"tips/#surface-generation-line-30","title":"Surface Generation (Line 30)","text":"<p>By combining \\(w\\) (0.6283), \\(t\\) (0.61), implicit function (gyroid), and input SDF, the output SDF was constructed.</p>"},{"location":"tips/#surface-visualization-line-31","title":"Surface visualization (Line 31)","text":"<p>The trigular mesh was generated from output SDF by dual marching cubes algorithm</p>"},{"location":"tips/#cleaning-line-34","title":"Cleaning (Line 34)","text":"<p>If <code>autoclean</code> option is enabled, the trigular mesh was cleaned by VGClib.</p>"},{"location":"tips/#smoothing-line-35","title":"Smoothing (Line 35)","text":"<p>The Laplacian smooth is used to fix the mis-shape faces from dual marching cube algorithm.</p>"},{"location":"tips/#topology-properties-line-37","title":"Topology properties (Line 37)","text":"<p>In order to fabricate with 3D printer, make sure that 3D mesh is watertight. Thus, the program asserts whether the 3D mesh is two-manifold or not. Moreover, the number non-manifold and border edges are reported, which should be zero to ensure the watertight property of the 3D mesh.  </p>"},{"location":"tips/#scaffold-properties-line-46","title":"Scaffold properties (Line 46)","text":"<p>Finally, the scaffold property such as volume (\\(\\text{unit}^3\\)), surface area (\\(\\text{unit}^2\\)), porosity, and surface area ratio were reported.</p> \\[ Porosity = 1 - \\left|\\frac{\\text{Volume}_{output}}{\\text{Volume}_{input}}\\right| \\] \\[     \\text{Surface Area Ratio (SAR)} = \\left|\\frac{\\text{Surface area}_{output}}{\\text{Surface area}_{input}}\\right| \\]"},{"location":"tips/#how-to-intrepret-the-output-from-console-2","title":"How to intrepret the output from console? (2)","text":"<p>If the <code>Analysis microstructure</code> (<code>-m</code>) is added to the previous command: <pre><code>.\\Scaffolder.exe .\\cube20mm.stl out.stl gyroid,0.6283,0.61,100 -m\n</code></pre></p> <p>an additional output from microstructure measurement will be reported (Line 47). <pre><code>[Scaffolder v1.5.1]\n-- Input file: .\\cube20mm.stl\n-- Output file: out.stl\n-- Surface (-n): gyroid\n-- Coff (-c): 0.6283\n-- Isolevel (-t): 0.61\n-- Grid size (-g): 100\n--   Grid offset: 3\n--   Shell: 0\n-- Autoclean: True\n--   Minimum diameter: 25%\n--   Smooth step: 5\n--   Fix self-intersect: False\n--   Quadric Simplification (-z): 0\n-- Analysis microstructure (-m): True\n--   Slice grid (k_slice): 100\n--   Nearest outer contours (k_polygon): 4\n--   Export microstructure: False\n--   Mean curvature: False\n-- Export JPEG: No\n--   Axis: X\n-- Build: Yes(Intersect)\n-- Bounding Box: [0, 0, 0] [20, 20, 20]\n-- Length: [20, 20, 20]\n-- Grid delta: 0.2\n[Generating grid] OK\n-- Grid size: 1191016 [106, 106, 106]\n[Calculating Winding number] OK\n-- Sign Distance: [ -1.03923, 9.99999]  Wind: [ -2.86488e-06, 1]\n[Generating isosurface Fxyz] OK\n[Marching Cube]\n[========================================] 100% 0.202s\n-- Info: 105896 vertices 211896 faces\n[libVCG Cleaning] OK\n[Laplacian smoothing] OK\n-- is_manifold: 1\n[Topology Measurement]\n-- Mesh is composed by 1 connected component(s)\n-- border edge: 0\n-- non-manifold edge: 0\n-- non-manifold vertex: 0\n-- self-intersect faces: 840\n-- Mesh is two-manifold\n-- Mesh has 0 holes\n-- Genus is 27\n[=======================================&gt;] 98% 1.939s\n[Microstructure]\n-- Avg Min Feret: 3.1344\n-- Avg Max Feret: 8.62469\n-- Min Feret: [1.05429 2.39338 3.18016 3.8397 9.99987]\n-- Max Feret: [3.52792 5.91049 7.67635 11.9059 14.8046]\n-- Square Similarity: [0 0 0 0 0]\n-- Circle Similarity: [0 0 0 0 0]\n-- Triangle Similarity: [0 0 0 0 0]\n-- Ellipse Similarity: [0 0 0 0 0]\n-- Elongation Similarity: [0 0 0 0 0]\n[Scaffold properties]\n-- Volume: 2267.63\n-- Surface Area: 2855.25\n-- Porosity: 0.716547\n-- Surface Area ratio: 1.18969\n[Writing file] OK\n[Finished]\n</code></pre></p>"},{"location":"tips/#feret-diameter","title":"Feret Diameter","text":"<p>Feret diameter, or caliper diameter, is a diameter of an object measured with a caliper. According to the above image, \\(\\upvarphi\\) and \\(\\Phi\\) are the minimum and maximum Feret diameter, respectively.</p> <p>The minimum and maximum of Feret diameters are collected. The interquartile ranges (IQR) reported in Line 50-51 are formatted as [Min, Q1, Median, Q3, Max].</p>"},{"location":"tpms/","title":"TPMS","text":""},{"location":"tutorial_1/","title":"Gyroid Sphere","text":"<p>In this tutorial, we will generate gyroid scaffold from <code>sphere.stl</code> whose bounding box is \\(2 \\times 2 \\times 2\\). In order to generate porous mesh, the implicit function (<code>gyroid</code> for this case),  angular frequency (\\(w\\)), and isolevel (\\(t\\)) are required (See Command line).</p>"},{"location":"tutorial_1/#angular-frequency","title":"Angular frequency","text":"<p>According to prior study, \\(w\\) is inversely proportational to the pore size (see Tips). That is, when \\(w\\) increases, the pore size will be decreased. For gyroid, \\(w \\approx \\pi/\\text{pore size}\\). If we want pore size of 0.25 (unit as same as <code>sphere.stl</code>), we try to initially set \\(w = \\pi/0.25 \\approx 12\\) </p>"},{"location":"tutorial_1/#isolevel","title":"Isolevel","text":"<p>\\(t\\) is directly proportional to the porosity. In the other word, if we want to increase porosity, we have to increase \\(t\\)!. However, some values of \\(t\\) are probably lead to the problematic 3D mesh. Thus we initially leave this value to the default (\\(t=0\\)).</p>"},{"location":"tutorial_1/#grid-size","title":"Grid size","text":"<p>Grid size is a resolution of the output 3D mesh. Unless we generate a 3D mesh for FEA, this parameter is leave as a default value of 100.</p> <p>Parameters summary</p> <p>input file = <code>sphere.stl</code>, surface = <code>gyroid</code>, coff (\\(w\\)) = <code>12</code>, isolevel (\\(t\\)) = <code>0</code>, grid size = <code>100</code></p>"},{"location":"tutorial_1/#command-line","title":"Command line","text":"<p><pre><code>Scaffolder sphere.stl out.stl gyroid,12,0,100 -m\n</code></pre> We add <code>-m</code> or <code>--microstructure</code> to enable the pore size evaluation. Then the console output is reported as the following: <pre><code>[Scaffolder v1.5.1]\n-- Input file: .\\sphere.stl\n-- Output file: out.stl\n-- Surface (-n): gyroid\n-- Coff (-c): 12\n-- Isolevel (-t): 0 \n-- Grid size (-g): 100\n--   Grid offset: 3\n--   Shell: 0\n-- Autoclean: True\n--   Minimum diameter: 25%\n--   Smooth step: 5\n--   Fix self-intersect: False\n--   Quadric Simplification (-z): 0\n-- Analysis microstructure (-m): True\n--   Slice grid (k_slice): 100\n--   Nearest outer contours (k_polygon): 4\n--   Export microstructure: False\n--   Mean curvature: False\n-- Export JPEG: No\n--   Axis: X\n-- Build: Yes(Intersect)\n-- Bounding Box: [-0.9995, -0.9995, -0.9995] [0.9995, 0.9995, 0.9995]\n-- Length: [1.999, 1.999, 1.999]\n-- Grid delta: 0.01999\n[Generating grid] OK\n-- Grid size: 1191016 [106, 106, 106]\n[Calculating Winding number] OK\n-- Sign Distance: [ -0.834758, 0.998785]  Wind: [ -0.00238368, 1.00151]\n[Generating isosurface Fxyz] OK\n[Marching Cube]\n[========================================] 100% 0.194s\n-- Info: 118708 vertices 237636 faces\n[libVCG Cleaning] OK\n-- is_manifold: 1\n[Topology Measurement]\n-- Mesh is composed by 1 connected component(s)\n-- border edge: 0\n-- non-manifold edge: 0\n-- non-manifold vertex: 0\n-- self-intersect faces: 1831\n-- Mesh is two-manifold\n-- Mesh has 0 holes\n-- Genus is 107\n[=======================================&gt;] 98% 2.1s7s\n[Microstructure]\n-- Avg Min Feret: 0.0893954\n-- Avg Max Feret: 0.606401\n-- Min Feret: [0.00073122 0.033939 0.105832 0.131947 0.615222]\n-- Max Feret: [0.00132485 0.243246 0.630859 0.723238 1.91447]\n-- Square Similarity: [0 0 0 0 0]\n-- Circle Similarity: [0 0 0 0 0]\n-- Triangle Similarity: [0 0 0 0 0]\n-- Ellipse Similarity: [0 0 0 0 0]\n-- Elongation Similarity: [0 0 0 0 0]\n[Scaffold properties]\n-- Volume: 2.04856\n-- Surface Area: 29.5085\n-- Porosity: 0.508139\n-- Surface Area ratio: 2.35532\n[Writing file] OK\n[Finished]\n</code></pre></p>"},{"location":"tutorial_1/#adjust-isolevel-for-60-porosity","title":"Adjust isolevel for 60% porosity","text":"<p>Suppose that the target porosity is 60%. Then we increase \\(t\\) to 1 and generate 3D mesh again</p> <pre><code>Scaffolder sphere.stl out.stl gyroid,12,1,100 -m -q\n</code></pre> <p>This time, we add <code>-q</code> or <code>--quite</code> to prevent the verbose output. The program will save the report in a file (<code>&lt;output_name&gt;_&lt;surface&gt;&lt;timestamp&gt;.txt</code>) instead. We use binary search to adjust the new value of \\(t\\) to find the optimal value with the 60% porosity. </p> \\(t\\) 0 1 0.5 0.25 0.375 0.3125 0.28 0.265 Porosity 0.508 0.85 0.67 0.59 0.634 0.613 0.602 0.597 <p>We can also use the classical numerical method called Secant method to find the optimal \\(t\\) for the target porosity.</p> \\[ F(t) = Porosity(t) - 0.6 = 0 \\] \\[ t_{next} = t_{current} - F(t_{current})\\frac{t_{current} - t_{old}}{F(t_{current}) - F(t_{old})} \\] \\[ t_{next} = t_{current} - (\\text{Porosity}_{current} - 0.6)\\frac{t_{current} - t_{old}}{\\text{Porosity}_{current} - \\text{Porosity}_{old}} \\] \\(t\\) 0 1 0.27 Porosity 0.508 0.85 0.5989"},{"location":"tutorial_2/","title":"TPMS with Python through SDF and PyScaffolder","text":"<p>Author: Jirawat Iamsamang Colab: https://github.com/nodtem66/Scaffolder/blob/master/docs/jupyter/TPMS.ipynb</p>"},{"location":"tutorial_2/#abstract","title":"Abstract","text":"<p>SDF provides a class for discretizing and visualizing any implicit surfaces. The basic topologies (e.g. sphere, box) are already defined.</p> <p>This notebook shows how to utilize this library to generate gyroid surface.</p>"},{"location":"tutorial_2/#installation","title":"Installation","text":"<ul> <li> <p>Currently, SDF is not in PyPI. So the github of SDF needs to clone into local computer. See Installation</p> </li> <li> <p>PyScaffolder can be installed by <code>pip install PyScaffolder</code></p> </li> </ul>"},{"location":"tutorial_2/#the-list-of-implicit-functions","title":"The list of implicit functions","text":"Name F(x,y,z) Schwarz-P cos\u2061(x)+cos\u2061(y)+cos\u2061(z) Double Schwarz-P cos\u2061(x)  cos\u2061(y)+  cos\u2061(y)  cos\u2061(z)+ cos\u2061(x)  cos\u2061(z)+  0.35 [cos\u2061(2x)+cos\u2061(2y)+cos\u2061(2z)] Diamond sin\u2061(x)  sin\u2061(y)  sin\u2061(z)+sin\u2061(x)  cos\u2061(y)  cos\u2061(z) + cos\u2061(x)  sin\u2061(y)  cos\u2061(z)+  cos\u2061(x)  cos\u2061(y)  sin\u2061(z) Double Diamond sin\u2061(2x)  sin\u2061(2y)+ sin\u2061(2y)  sin\u2061(2z) + sin\u2061(2z)  sin\u2061(2x)+  cos\u2061(2x)  cos\u2061(2y)  cos\u2061(2z) Gyroid cos\u2061(x)  sin\u2061(y)+cos\u2061(y)  sin\u2061(x)+cos\u2061(z)  sin\u2061(x) Double Gyroid 2.75 [ sin(2x)  sin\u2061(z)  cos\u2061(y)+sin\u2061(2y)  sin\u2061(x)  cos\u2061(z) + sin\u2061(2z)  sin\u2061(y) cos\u2061(x) ] - [ cos\u2061(2x)cos\u2061(2y)+ cos\u2061(2y)  cos\u2061(2z)+cos\u2061(2z) cos\u2061(2x)  ] Lidinoid sin\u2061(2x)  cos\u2061(y)  sin\u2061(z)+sin\u2061(2y)  cos\u2061(z)  sin\u2061(x)+ sin\u2061(2z)  cos\u2061(x)  sin\u2061(y)+ cos\u2061(2x)  cos\u2061(2y)+ cos\u2061(2y)  cos\u2061(2z)+cos\u2061(2z)  cos\u2061(2x) Neovius 3 [cos\u2061(x)+cos\u2061(y)+cos\u2061(z) ]+4 [cos\u2061(x)  cos\u2061(y)  cos\u2061(z) ] Schoen IWP cos\u2061(x)  cos\u2061(y)+cos\u2061(y)  cos\u2061(z)+cos\u2061(z)  cos\u2061(x) Tubular G AB 20 [cos\u2061(x)  sin\u2061(y) + cos\u2061(y)  sin\u2061(z)+cos\u2061(z)  sin\u2061(x)  ] -0.5 [cos\u2061(2x)  cos\u2061(2y)+cos\u2061(2y)  cos\u2061(2z)+cos\u2061(2z)  cos\u2061(2x) ] -4 Tubular G C -10 [cos\u2061(x)  sin\u2061(y)+cos\u2061(y)  sin\u2061(z)+cos\u2061(z)  sin\u2061(x) ] +2[cos\u2061(2x)  cos\u2061(2y)+cos\u2061(2y)  cos\u2061(2z)+cos\u2061(2z)  cos\u2061(2x)  ] +12 BCC cos\u2061(x)+cos\u2061(y)+cos\u2061(z)-2 [ cos\u2061(x/2)cos\u2061(y/2) + cos\u2061(y/2)cos\u2061(z/2)+cos\u2061(z/2)cos\u2061(x/2) ]"},{"location":"tutorial_2/#gyroid","title":"Gyroid","text":"<p>The gyroid function is defined as shown in a following cell.  </p> <p>The wrapper <code>@sdf3</code> will provide gyroid function with 3D points (<code>p</code>)).</p> <p>Then these (x,y, z) points will multiply by <code>w</code> and calculate the iso-level of gyroid by vectorized numpy function. </p> <pre><code>%load_ext autoreload\n%autoreload 2\n\nimport numpy as np\nimport PyScaffolder\nfrom sdf import *\n\n@sdf3\ndef gyroid(w = 3.14159, t=0):\n    def f(p):\n        q = w*p\n        x, y, z = (q[:, i] for i in range(3))\n        return np.cos(x)*np.sin(y) + np.cos(y)*np.sin(z) + np.cos(z)*np.sin(x) - t\n    return f\n</code></pre>"},{"location":"tutorial_2/#generate-with-skimage","title":"Generate with SKimage","text":"<p>SDF used <code>marching_cubes</code> from <code>skimage.measure</code> with a <code>ThreadPool</code>, so it's super fast to construct the 3D mesh. Let's create a constructing function that intersect a gyroid and a unit box.</p> <pre><code># Generate with skimage.measure.marching_cubes\nf = box(1) &amp; gyroid(w=12)\npoints = f.generate(step=0.01, verbose=True)\n\nwrite_binary_stl('out_1.stl', points)\n</code></pre> <pre><code>min -0.565721, -0.565721, -0.565721\nmax 0.565722, 0.565722, 0.565722\nstep 0.01, 0.01, 0.01\n1601613 samples in 64 batches with 16 workers\n\n7 skipped, 0 empty, 57 nonempty\n233958 triangles in 0.659682 seconds\n</code></pre>"},{"location":"tutorial_2/#generate-with-pyscaffolder","title":"Generate with PyScaffolder","text":"<p>However, this method occasionally results in incomplete mesh. Then let's try <code>Pyscaffolder.marching_cubes</code> which implements <code>dual marching cubes</code> from @dominikwodniok/dualmc.</p> <pre><code># Generate with PyScaffolder.marching_cubes\n\ndef marching_cubes(f, step=0.01, bounds=None, verbose=True, clean=True):\n    from sdf.mesh import _estimate_bounds, _cartesian_product\n    import time\n\n    if not bounds:\n        bounds = _estimate_bounds(f)\n\n    (x0, y0, z0), (x1, y1, z1) = bounds\n\n    try:\n        dx, dy, dz = step\n    except TypeError:\n        dx = dy = dz = step\n\n    if verbose:\n        print('min %g, %g, %g' % (x0, y0, z0))\n        print('max %g, %g, %g' % (x1, y1, z1))\n        print('step %g, %g, %g' % (dx, dy, dz))\n\n    X = np.arange(x0, x1, dx)\n    Y = np.arange(y0, y1, dy)\n    Z = np.arange(z0, z1, dz)\n    P = _cartesian_product(X, Y, Z)\n\n    try:\n        # Since the PyScaffolder marching_cubes aceept FREP: F(x,y,z) &gt; 0\n        # Then the negative of implicit function is used\n        Fxyz = (-f(P))\n        # Reshape to Fortran array (column-based) due to implementation of dualmc starting from z axis to x\n        Fxyz = Fxyz.reshape((len(X), len(Y), len(Z))).reshape(-1, order='F')\n        start = time.time()\n        (v, f) = PyScaffolder.marching_cubes(Fxyz, grid_size=[len(X), len(Y), len(Z)], v_min=bounds[0], delta=step, clean=clean)\n        if verbose:\n            seconds = time.time() - start\n            print('\\n%d triangles in %g seconds' % (len(points) // 3, seconds))\n        # merge vertices and faces into points\n        return v[f].reshape((-1, 3))\n\n    except Exception as e:\n        print(e)\n        return np.array([])\n\npoints = marching_cubes(f, step=0.01, verbose=True, clean=True)\nwrite_binary_stl('out_2.stl', points)\n</code></pre>"},{"location":"tutorial_2/#generate-the-other-tpms","title":"Generate the other TPMS","text":"<p>The following codes will define and generate SchwarzP and BCC structure.</p> <p>Define the implicit functions</p> <p><pre><code>@sdf3\ndef schwarz_p(w = 3.14159, t=0):\n    def f(p):\n        q = w*p\n        x, y, z = (q[:, i] for i in range(3))\n        return np.cos(x) + np.cos(y) + np.cos(z)\n    return f\n\n@sdf3\ndef bcc(w = 3.14159, t=0):\n    def f(p):\n        q = w*p\n        x, y, z = (q[:, i] for i in range(3))\n        return np.cos(x) + np.cos(y) + np.cos(z) -2*(np.cos(x/2)*np.cos(y/2) + np.cos(y/2)*np.cos(z/2) + np.cos(z/2)*np.cos(x/2))\n    return f\n</code></pre> Generate STL</p> <pre><code># Define f2 as an union between Schwarz P and a box\nf2 = box(1) &amp; schwarz_p(w=12)\npoints = marching_cubes(f2, step=0.01, verbose=True, clean=True)\nwrite_binary_stl('schwarz_p.stl', points)\n\n# Likewise, f3 was defined as an union between BCC and a box\nf3 = box(1) &amp; bcc(w=12)\npoints = marching_cubes(f3, step=0.01, verbose=True, clean=True)\nwrite_binary_stl('bcc.stl', points)\n</code></pre>"}]}